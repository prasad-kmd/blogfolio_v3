<!-- Section: CTA Form -->
<section class="backlight-top is-fullwidth">
    <div class="stg-row stg-valign-middle stg-cta-with-image stg-tp-column-reverse">
        <div class="stg-col-5" data-unload="fade-left">
            <div class="pmbsweb-offset-image" data-bg-src="img/cta/contact-section-bg.jpg" data-appear="fade-up" data-threshold="0.25"></div>
            <form id="telegram_form" class="pmbsweb-contact-form pmbsweb-block" data-fill-error="Please, fill out the contact form." data-appear="fade-right" data-threshold="0.25">
                <div class="pmbsweb-form-content">
                    <!-- Field: Name -->
                    <label for="name">Your Name</label>
                    <input type="text" id="name" name="name" placeholder="Your Name" required>
                    <!-- Field: Email -->
                    <label for="email">Your Email</label>
                    <input type="email" id="email" name="email" placeholder="email@example.com" required>
                    <!-- Field: Phone Number -->
                    <label for="phone">Your Mobile Number (Optional)</label>
                    <input type="text" id="phone" name="phone" placeholder="+94111111111">    
                    <!-- Field: Message -->
                    <label for="message">Your Message</label>
                    <textarea id="message" name="message" placeholder="Your Message" required></textarea>
                    <!-- Form Button -->
                    <button type="submit" value="Send Message">Send Message</button>
                    <div class="pmbsweb-contact-form__response"></div>
                </div>
                <span class="pmbsweb-form-spinner"></span>
            </form>
        </div>
        <div class="stg-col-6 stg-offset-1" data-unload="fade-right">
            <div class="pmbsweb-cta-form-content">
                <div class="pmbsweb-cta-form-title" data-split-appear="fade-up" data-split-delay="100" data-split-by="line">
                    Let's discuss about next creative project.
                </div>
                <div class="pmbsweb-cta-text">
                    <div class="stg-row stg-valign-middle">
                        <div class="stg-col-2 stg-offset-2 stg-tp-col-1 stg-tp-offset-3 stg-m-col-1 stg-m-offset-2" data-appear="fade-right">
                            <i class="pmbsweb-cta-icon"></i>
                        </div>
                        <div class="stg-col-8 stg-tp-col-7 stg-m-col-8 stg-m-offset-1" data-appear="fade-left">
                            <p class="pmbsweb-large-text">{{ site.description }}.</p>
                        </div>
                    </div>
                </div>
                <div class="pmbsweb-cta-counters pmbsweb-grid-3cols pmbsweb-m-grid-3cols" data-stagger-appear="fade-up" data-stagger-delay="100">
                    <!-- Counter Item -->
                    <div class="pmbsweb-counter pmbsweb-small-counter" data-delay="3000">
                        <div class="pmbsweb-counter-number">{{ len .Site.Data.portfolio }}</div>
                        <div class="pmbsweb-counter-label">Projects Done</div>
                    </div><!-- .pmbsweb-counter -->
                    <!-- Counter Item -->
                    <div class="pmbsweb-counter pmbsweb-small-counter" data-delay="3000">
                        <div class="pmbsweb-counter-number" data-suffix="+">{{ len .Site.RegularPages }}</div>
                        <div class="pmbsweb-counter-label">Total Posts</div>
                    </div><!-- .pmbsweb-counter -->
                    <!-- Counter Item -->
                    <div class="pmbsweb-counter pmbsweb-small-counter" data-delay="3000">
                        <div class="pmbsweb-counter-number" data-suffix="+">{{ .Site.Params.experience }}</div>
                        <div class="pmbsweb-counter-label">Years in Work</div>
                    </div><!-- .pmbsweb-counter -->
                </div>
            </div>
        </div>
    </div>
</section>

  <script>
    /*! Telegram Bot Form Handler */
    function handleTelegram(e = {}) { const t = { get title() { return document.title }, get homepage() { return c.origin }, get page() { this.homepage, c.pathname } }, r = { stringify: e => `${"string" == typeof e ? e : JSON.stringify(e)}`, escapeHTML: e => e.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/>/g, "&lt;"), objectToFormData(e) { const t = new FormData, r = (e, r, n) => { ["string", "number", "boolean"].includes(typeof r) ? t.append(e, `${r}`) : r instanceof Blob && t.append(e, r, n) }; return Object.keys(e).forEach((t => { const n = e[t]; Array.isArray(n) ? n.forEach((e => r(t, e))) : r(t, n) })), t }, getFormData(e) { const t = Object.defineProperties({}, { toArray: { value() { return Object.keys(this).map((e => this[e])) } }, toValues: { value() { return Object.keys(this).reduce(((e, t) => (e[t] = this[t].value, e)), {}) } } }), { elements: r } = e, n = Object.keys(r).map((e => r[e].name)).filter(((e, t, r) => r.indexOf(e) === t && e)); for (let e = 0; e < n.length; e += 1) { const o = n[e], a = r[o], i = { element: a, name: o, type: a.type }; switch (a.type) { case "checkbox": i.value = a.checked; break; case "file": i.value = Array.from(a.files), i.multiple = a.multiple; break; case "select-multiple": i.value = Array.from(a.options).filter((e => e.selected)).map((e => e.value)); break; case "date": case "datetime-local": i.value = ["" === a.value ? null : a.value, isNaN(a.valueAsNumber) ? null : a.valueAsNumber]; break; default: i.value = "" === a.value ? null : a.value }t[o] = i } return t } }, n = { error(r, n) { if ("function" != typeof e.onError) throw r; e.onError(r, n, t) }, validate: (r, n) => "function" != typeof e.validate || !0 === e.validate(r, n, t), submit(r, n, o) { "function" == typeof e.onSubmit && e.onSubmit(r, n, o, t) }, sent(r, n, o) { "function" == typeof e.onSent && e.onSent(r, n, o, t) }, notSent(r, n, o, a) { "function" == typeof e.onNotSent && e.onNotSent(r, n, o, a, t) }, complete(r, n, o, a) { "function" == typeof e.onComplete && e.onComplete(r, n, o, a, t) }, format(n, o, a) { if ("function" == typeof e.format) { const r = e.format(n, o, a, t); if ("string" == typeof r) return r } let i = ""; return Object.keys(n).forEach((e => { const t = n[e]; "file" !== t.type && (i && (i += "\n\n"), i += `Field: ${r.escapeHTML(e)}\nValue: <pre><code>${r.escapeHTML("string" == typeof t.value ? t.value : JSON.stringify(t.value))}</code></pre>`) })), i }, caption(n, o, a, i) { if ("function" == typeof e.caption) { const r = e.caption(n, o, a, i, t); if ("string" == typeof r) return r } return `Field: ${r.escapeHTML(o.name)}\nName: ${r.escapeHTML(n.name)}\nType: ${r.escapeHTML(n.type)}\nModified at: ${new Date(n.lastModified).toJSON()}` } }, { form: o, token: a, chat: i, thread: s } = e, { location: c } = window, l = () => { }; if (!o instanceof HTMLFormElement) return n.error(new TypeError("Field 'form' must be an HTMLFormElement")), l; if ("string" != typeof a) return n.error(new TypeError("Field 'token' must be of type string"), o), l; if ("string" != typeof i && "number" != typeof i) return n.error(new TypeError("Field 'chat' must be of type string or number"), o), l; if ("thread" in e && "string" != typeof s && "number" != typeof s) return n.error(new TypeError("Field 'thread' must be of type string or number"), o), l; const p = (e => ({ get token() { return e }, get url() { return `https://api.telegram.org/bot${this.token}` }, async request(e, t) { const n = `${this.url}/${e}`; let o = t; t && (o.reply_markup || o.entities) && (o = { ...t }, o.reply_markup && (o.reply_markup = r.stringify(o.reply_markup)), o.entities && (o.entities = r.stringify(o.entities))); const a = o ? r.objectToFormData(o) : void 0, i = new Request(n, { method: "POST", body: a, headers: { Accept: "application/json" } }), s = await fetch(i).then((e => { const t = e.headers.get("Content-Type"); return t && t.startsWith("application/json") ? e.json() : null })); if (s) { if (s.ok) return s.result; if (s.description) throw new Error(s.description) } throw new Error("Response is invalid") }, async sendMessage(e, t, r) { return this.request("sendMessage", { ...r, chat_id: e, text: t }) }, async sendMediaGroup(e, t, n) { const o = {}; return t && t.forEach(((e, r) => { if (e && e.media instanceof Blob) { const n = `file_attach_id_${r}`; o[n] = e.media, t[r] = { ...e, media: `attach://${n}` } } })), this.request("sendMediaGroup", { ...n, ...o, chat_id: e, media: r.stringify(t) }) } }))(a), u = e => { e.preventDefault(); const a = r.getFormData(o); if (n.submit(e, a, o), n.validate(a, t, o)) { const e = a.toArray().filter((e => "file" === e.type)).reduce(((e, t) => (t.value.forEach((r => { const i = n.caption(r, t, a, o); e.push({ type: "document", media: r, caption: i, parse_mode: "html" }) })), e)), []); if (0 !== e.length) { e[e.length - 1].caption += `\n\n${n.format(a, e, o)}`, p.sendMediaGroup(i, e, { message_thread_id: s }).then((e => { try { n.sent(e, a, o), n.complete(!0, e, a, o) } catch (e) { n.error(e, o) } })).catch((e => { n.notSent(e, "bot", a, o), n.error(e, o), n.complete(!1, e, a, o) })) } else p.sendMessage(i, n.format(a, void 0, o), { message_thread_id: s, parse_mode: "html" }).then((e => { try { n.sent(e, a, o), n.complete(!0, e, a, o) } catch (e) { n.error(e, o) } })).catch((e => { n.notSent(e, "bot", a, o), n.error(e, o), n.complete(!1, e, a, o) })) } else { const e = new Error("Validation Failed"); n.notSent(e, "validation", a, o), n.complete(!1, e, a, o) } }; return o.addEventListener("submit", u), () => { o.removeEventListener("submit", u) } }
  </script>
  
  <script>
    // Toast Notification function
    function toast(m) {
        var e = document.getElementById('toast_notificationpm');
        if (e !== null) {
            e.innerHTML = `<span>${m}</span>`;
        } else {
            alert(m);
        }
    }

    const formElement = document.getElementById("telegram_form");
    const submitButton = formElement.querySelector("button");

    // Fetch secrets from the Vercel API
    fetch('/api/secrets')
        .then(response => response.json())
        .then(data => {
            const TELEGRAM_TOKEN = data.telegram_token;
            const TELEGRAM_CHAT_ID = data.telegram_chat_id;

            // Attach onSubmit Event listener and send data to telegram
            const unsubscribe = handleTelegram({
                form: formElement,
                token: TELEGRAM_TOKEN,
                chat: TELEGRAM_CHAT_ID,

                // Formatting
                format(data, media, form) {},
                caption(file, field, data, form) {},

                // Validation
                validate(data, form) {
                    if (!data.name.value) {
                        data.name.element.focus();
                        return toast("Enter your name!");
                    }

                    if (!data.email.value) {
                        data.email.element.focus();
                        return toast("Enter your email!");
                    }

                    return true;
                },

                // Callbacks
                onSubmit(event, data, form) {
                    submitButton.disabled = true;
                },
                onComplete(success, response, data, form) {
                    submitButton.disabled = false;
                },
                onSent(response, data, form) {
                    toast(`Hey, ${data.name.value}! Form submitted!`);
                    // Reset form after submission
                    formElement.reset();
                },
                onNotSent(error, reason, data, form) {
                    if (reason !== "validation") {
                        toast(`Form failed to submit! (${(error || {}).message || "Unknown"})`);
                    }
                },
                onError(error, form) {
                    console.log(error);
                },
            });
        })
        .catch(error => console.error("Error fetching secrets:", error));
</script>
